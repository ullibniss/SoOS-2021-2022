### 1 Что происходит при прерывании скрипта text-trap.sh? Объясните, почему.  
	Когда мы нажимаем  Ctl+C, терминалом посылается сигнал SIGINT процессу, который контролирует терминал.  
	С помощью build-in утилиты trap мы установили триггер на сигнал SIGINT, а когда trap ловит сигнал выполняет свой список действий.   
	В нашем случае 'echo Аварийное завершение...'
	
### 2 Напишите, по какой причине выводы команды ls -l /proc/self и ls -l /proc/$$ отличаются?
	Я понимаю разницу, но не уверен, что смогу корректно ее объяснить.
	
	Дело в том, что когда мы смотрим /proc/self, на возврат мы получаем ссылку на pid процесса, который обращается к /proc/self.
	А когда мы вызывваем $$, возвращается pid процесса внутри которого вызвали $$.
	
### 3 Напишите, какие дескрипторы в выводе команды ls -l /proc/self/fd отвечают за stdin, stdout, stderr.
	0 - stdin
	1 - stdout
	2 - stderr

### 4 Что происходит с дескрипторами при перенаправлении потоков stdout и stderr в файлы при выполнении команды ls -l /proc/self/fd > /tmp/ls.out 2> /tmp/ls.err?


	Файловые дескрипторы в линухе находятся в /proc/[pid]/fd и представлены в видео симлинков на объект, в которые они передают или откуда берут данные. 
	Соответсвенно, когда мы stdout и stderr команды ls направим в файлы /tmp/ls.out /tmp/ls.err у нас будет так:   
	
		lrwx------. 1 alexey alexey 64 сен 11 21:56 0 -> /dev/pts/1
		l-wx------. 1 alexey alexey 64 сен 11 21:56 1 -> /tmp/ls.out
		lrwx------. 1 alexey alexey 64 сен 11 21:56 2 -> /tmp/ls.err
	
	А 0 направлен в псевдотерминал(pts) так, как он берет оттуда данные, все просто.
	
### 5 Запишите эту же команду, добавив к ней перенаправление потока stdin. Что изменилось?
	
	Она выведет всю ту же папку файловых дескрипторов, только в 0й фд будет ссылаться на файл переданный в stdin
	
### 6 Какой эффект наблюдается при выполнении команды exec ps -l  
	
	 Наблюдается выход из оболочки. Оно и логично потому, что когда мы вызываем exec и первым аргументом передаем исполняемый файл, то это файл(комманда) заменяет текущую оболочку. В итоге получается так, что команда заменяет интерактивную пользовательстую среду - на свою.

### 7 Что означает pos при выводе содержимого файла /proc/$$/fdinfo/3
[картинка1](https://user-images.githubusercontent.com/55274498/135946974-75b82d9f-14de-4d5c-8dd6-8bbcab5cbc26.png)  
[картинка2](https://user-images.githubusercontent.com/55274498/135947490-79755c05-390f-480e-bd65-3edbae165f56.png)

	 pos - показывает текущую позицию или смещение в открытом сеансе.
	 
	 на картинке 1 я открыл в самом левом терминале tail -f file, для того, чтобы отслеживать изменения в файле.  
	 По центру использую watch cat /proc/[pid]/fdinfo/*, чтобы выдеть информацию о файловых дескрипторах,  
	 в правой части накидываю текста с помощью echo. И на второй картинке видно, что позиция 3го декриптора изменяется, когда я пушу текст в файл.
	 
### 8 Существует ли возможность читать содержимое файла test.out даже после его удаления? Почему так происходит?  
[картинка](https://user-images.githubusercontent.com/55274498/135952311-b38eb01d-64c1-48e1-acd0-ba0efefa4e09.png)
	
	Ну с помощью cat - нельзя. 
	Но если передать в фд: exec 4< test.out, то можно выплюнуть содержимое удаленного файла один раз таким образом: cat <&4
	Происходит это из-за того, что вероятно файловый дескриптор сохраняет и переданные в него данные и адресс файла,
	когда файл удаляют, остаются только данные и он их выплевывает, а взять их не откуда, потому, что вместо адреса - NULL. 
	
	На картинке пример
	

	 
